<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>GPM on 不积跬步无以至千里</title>
        <link>https://x-xkang.com/tags/gpm/</link>
        <description>Recent content in GPM on 不积跬步无以至千里</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 22 Oct 2024 10:13:33 +0800</lastBuildDate><atom:link href="https://x-xkang.com/tags/gpm/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Golang GPM模型</title>
        <link>https://x-xkang.com/p/golang-gpm%E6%A8%A1%E5%9E%8B/</link>
        <pubDate>Tue, 22 Oct 2024 10:13:33 +0800</pubDate>
        
        <guid>https://x-xkang.com/p/golang-gpm%E6%A8%A1%E5%9E%8B/</guid>
        <description>&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://x-xkang.com/images/golang/GPM/overview.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;概览图&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;gpm-分别代表&#34;&gt;GPM 分别代表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;G: Goroutine, Go协程，是参与调度与执行的最小单元。&lt;/li&gt;
&lt;li&gt;P: P, Processor，指的是逻辑处理器，P关联了本地可运行的G队列，最多可存放256个G。P的数量最多是&lt;code&gt;GOMAXPROCS&lt;/code&gt;（可配置）个。&lt;/li&gt;
&lt;li&gt;M: M, Machine，指的是系统级线程，Go程序启动时会设置M的最大数量，默认为10000，但是内核很难支持这么多的线程，所以这个限制可以hulue。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- GPM的调度流程大致如下：

- 线程M想运行任务就需要获得P，即与P关联。
- 然后从P的本地队列获取G。
- 若本地队列中没有可运行的G，M会尝试从全局队列拿去一批G放到P的本地队列中。
- 若全局队列也未找到可运行的G时，M会随机从其他P的本地队列偷取一半放到自己P的本地队列中。
- 拿到可运行的G之后，M运行G，G执行之后，M会从P获取下一个G，以此往复。 --&gt;
&lt;h3 id=&#34;调度器的生命周期&#34;&gt;调度器的生命周期&lt;/h3&gt;
&lt;h4 id=&#34;m0&#34;&gt;m0&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;M0&lt;/code&gt;是启动程序后的编号为0的主线程，这个&lt;code&gt;M&lt;/code&gt;对应的实例会在全局变量runtime.m0中，不需要在Heap上分配，M0负责执行初始化操作和启动第一个&lt;code&gt;G&lt;/code&gt;，在之后M0就和其他的 &lt;code&gt;M&lt;/code&gt; 一样了。&lt;/p&gt;
&lt;h4 id=&#34;g0&#34;&gt;G0&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;G0&lt;/code&gt;是每次启动一个 &lt;code&gt;M&lt;/code&gt;都会第一个创建的 goroutine，&lt;code&gt;G0&lt;/code&gt;仅用于负责调度的 &lt;code&gt;G&lt;/code&gt;，&lt;code&gt;G0&lt;/code&gt;不指向任何可执行的函数，每个&lt;code&gt;M&lt;/code&gt;都会有一个自己的&lt;code&gt;G0&lt;/code&gt;，在调度或者系统调用时会使用&lt;code&gt;G0&lt;/code&gt;的栈空间，全局变量的&lt;code&gt;G0&lt;/code&gt;是&lt;code&gt;M0&lt;/code&gt;的&lt;code&gt;G0&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Golang&#34; data-lang=&#34;Golang&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;以上代码所示，分析一下执行过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;runtime&lt;/code&gt; 创建最初的线程 &lt;code&gt;m0&lt;/code&gt; 和 goroutine &lt;code&gt;g0&lt;/code&gt;，并把二者关联。&lt;/li&gt;
&lt;li&gt;调度器初始化：初始化 m0、栈、垃圾回收，以及创建和初始化由 &lt;code&gt;GOMAXPROCS&lt;/code&gt;个 &lt;code&gt;P&lt;/code&gt; 构成的 &lt;code&gt;P&lt;/code&gt; 列表。&lt;/li&gt;
&lt;li&gt;示例代码中的 main 函数是 &lt;code&gt;main.main&lt;/code&gt;，&lt;code&gt;runtime&lt;/code&gt;中也有一个main函数 - &lt;code&gt;runtime.main&lt;/code&gt;，代码经过编译后，&lt;code&gt;runtime.main&lt;/code&gt;会调用 &lt;code&gt;main.main&lt;/code&gt;，程序启动时会为 &lt;code&gt;runtime.main&lt;/code&gt;创建&lt;code&gt;goroutine&lt;/code&gt;，称它为 &lt;code&gt;main goroutine&lt;/code&gt;。然后把 &lt;code&gt;main goroutine&lt;/code&gt; 加入到 &lt;code&gt;P&lt;/code&gt; 的本地队列中。&lt;/li&gt;
&lt;li&gt;启动&lt;code&gt;m0&lt;/code&gt;，&lt;code&gt;m0&lt;/code&gt;已经绑定了&lt;code&gt;P&lt;/code&gt;，会从&lt;code&gt;P&lt;/code&gt;的本地队列获取&lt;code&gt;G&lt;/code&gt;，然后获取到 &lt;code&gt;main goroutine&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt; 拥有栈， &lt;code&gt;M&lt;/code&gt; 根据 &lt;code&gt;G&lt;/code&gt; 中的栈信息和调度信息设置运行环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt; 运行 &lt;code&gt;G&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt;退出，再次回到&lt;code&gt;M&lt;/code&gt;获取可运行的&lt;code&gt;G&lt;/code&gt;，这样重复下去，直到&lt;code&gt;main.main&lt;/code&gt;退出，&lt;code&gt;runtime.main&lt;/code&gt; 执行 Defer 和 Panic 处理，或调用 &lt;code&gt;runtime.exit&lt;/code&gt; 退出程序。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
